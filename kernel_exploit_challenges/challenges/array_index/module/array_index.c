#include <linux/module.h>
#include <linux/kernel.h> /* printk() */
#include <asm/uaccess.h> /* copy_from/to_user */
#include <linux/fs.h> /* file_operations */
#include <linux/miscdevice.h>
#include "CommandHandler.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ryan Welton <Ryan.G.Welton@gmail.com>");
MODULE_DESCRIPTION("Buggered Linux Device for exploitation");
MODULE_VERSION("1.3.3.7");

static int doNothingIntializer(void);
static int doNothingIntializer(){
 return 0;
}

CommandHandler handlers[] = {
   {
     .runHandler = &doNothingIntializer
   },
   {
     .runHandler = &doNothingIntializer
   }
};

long ai_ch_ioctl(struct file *filp,
                  unsigned int cmd,
                  unsigned long arg)
{
 unsigned int handler_index = arg;

  switch (cmd) {
    case RUN_COMMAND_HANDLER:
       handlers[handler_index].runHandler();
       break;
    default :
       printk("Unknown ioctl cmd: %d", cmd);
       return -1;
  }
  return 0;
}

/* Structure that declares the usual file */
/* access functions */
struct file_operations device_fops = {
  unlocked_ioctl: ai_ch_ioctl
};

/*
Create our misc device - a char device that doesn't fit into any other device class
http://stackoverflow.com/questions/18456155/what-is-the-difference-between-misc-drivers-and-char-drivers
*/
static struct miscdevice vuln_device = {
        minor: MISC_DYNAMIC_MINOR,
        name: "array_index",
        fops: &device_fops,
        mode: 777
};

static int __init mod_begin(void)
{
   int ret;
   ret = misc_register(&vuln_device);
   if(ret)
     printk("Failed to register misc device");
   else
     printk("Module successfully loaded");

   return ret;//A non 0 return means init_module failed; module can't be loaded.
}

static void __exit mod_exit(void)
{
  int ret = misc_deregister(&vuln_device);
  if(ret)
    printk("There was an error unregistering device");
}

module_init(mod_begin);
module_exit(mod_exit);
