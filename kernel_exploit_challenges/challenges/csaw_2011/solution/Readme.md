#The Solution#

Ok, that should be enough! Now to the actual solution. Hopefully you were able to get past the first part of guessing the right key, which should be straightforward to any crypto folks based on the SqueamishOssifrage name or via a quick Google search:

http://en.wikipedia.org/wiki/The_Magic_Words_are_Squeamish_Ossifrage

Armed with the key, you can decrypt the flag.enc as follows:

```
$ echo "The Magic Words are Squeamish Ossifrage" > /proc/csaw/key
$ cat flag.enc > /proc/csaw/decrypt
$ cat /proc/csaw/decrypt
```
Congrats on decrypting the secret payload. Unfortunately, your flag is
not here. It is actually in /root/flag.txt. Good luck.
So, despite the appearance of the code, this was not actually a crypto challenge, but rather a kernel exploitation challenge. Would you expect anything else? ;-)

The next step in the challenge was to find the vulnerability in the SqueamishOssifrage kernel module. Most of the module is a hacked up TEA cipher that doesn’t really do anything interesting other than act as a red herring.

If you look in the key_write() function, you can see that there’s an undocumented ability to set the number of rounds of the TEA cipher:

```c
sscanf(buf, "%16c\t%d", (char *) key, &rounds);
```

So, you can set the TEA cipher to perform 666 rounds by doing:

```
echo -e "testtesttesttest\t666" > /proc/csaw/key
```
Now, the TEA cipher is implemented recursively, which is key (no pun intended) to the challenge. So the more rounds you specify, the deeper the call stack in the kernel.

On Linux kernels, you have a limited kernel stack (commonly 8k on x86). If you have a deeply recursive kernel function, especially one where the amount of recursion is controlled by an attacker, you may end up clobbering sensitive data in the thread_info structure which is stored at the base of your process’ kernel stack. More detailed info on Linux kernel stack overflows and how to exploit them is available here in a previous blog post:

http://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/

So if you made it this far, the challenge is more or less straightforward at this point. Just continue trying more rounds (and therefore a deeper kernel call stack) until the “tip” of the stack hits the restart_block.fn function pointer that is stored at the base of the kernel stack. You’ll probably crash the kernel a few times by recursing too deep and clobbering sensitive members of the thread_info structure, but with a few tries, you’ll eventually determine the right number of rounds to directly hit the restart_block member (which on the target VM/kernel was 114 rounds).

You can easily test whether your restart_block function pointer has been clobbered by calling the restart_syscall system call:

```c
syscall(__NR_restart_syscall);
```

In this case, the tip of the kernel stack is not directly under your control, but is indeed a userspace address (0x9e3779b9 passed as the last parameter to scramble/descramble). So by clobbering the restart_block function pointer with a userspace address, all you need to do is mmap your payload at that userspace address and trigger its execution via the restart_syscall system call.

To make the privesc a little more challenging, /proc/kallsyms is not readable as an unprivileged user, so retrieving the usual prepare_kernel_cred/commit_creds symbols is thwarted. However, I did leave a System.map world-readable in /boot which provides the equivalent symbols.

After escalating privileges, simply read the flag from /root/flag.txt.


Solution was found and modified from here:
```
http://security.cs.rpi.edu/~candej2/kernel/kernel_exploit.c
```
